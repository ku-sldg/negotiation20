Set Implicit Arguments.

Module DepCopland.

  (* Define three places named [AA], [BB], and [CC] *)
  Inductive place : Type :=
  | AA : place
  | BB : place
  | CC : place.

  (* Define two classification levels.  [red] is classified and [green] is
     unclassified. *)
  Inductive class : Type :=
  | red : class
  | green : class.

  Definition eq_class_dec: forall x y:class, {x=y}+{x<>y}.
  Proof.
    repeat decide equality.
  Defined.
  
  (* [evidence] type generated by term. The argument [n] allows for multiple
     subtypes.  [EBlob 1] is a different evidenence type than [EBlob 2]. All
     this does is allow more kinds of evidence without extending this type.

     - [EBlob class] - Arbitrary evidence that can be sensitive ([red]) or
       public ([green]).
     - [EHash] - Hash value.  All hash values are [green].
     - [EPrivKey p] - Private Key for place p.  [PubKey p] is
       inverse.  Always [red] and should never be exposed.
     - [EPubKey p] - Public Key for place p. [PrivKey p] is
       inverse. Usually safe?  Will treat as always [green] for this
       experiment.
     - [ESessKey n] - Symmetric session key. [n] allows recording which
       session key in the type.  Will treat as always [red] for this
       experiment.
     - [ECrypt e p] - [e] of type [evidence] encrypted with public
       key of [p].  Always safe and [green].
     - [ESig e p] - [e] signed by [private p].  Safe if [e] is safe, so can be
       either [red] or [green]
     - [ESeq l r] - Sequential composition of evidence [l] and [r].  [green] if
       [l] and [r] are [green].
     - [EPar l r] - Parallel composition of evidence [l] and [r].  [green] if
       [l] and [r] are [green].

     [evidence] is the type corresponding with these definitions.
   *)
  
  Inductive evidence : Type :=
  | EBlob : class -> evidence
  | EHash : evidence
  | EPrivKey : place -> evidence
  | EPubKey : place -> evidence
  | ESessKey : nat -> evidence
  | ECrypt : evidence -> place -> evidence
  | ESig : evidence -> place -> evidence
  | ESeq : evidence -> evidence -> evidence
  | EPar : evidence -> evidence -> evidence.

  Definition eq_ev_dec: forall x y:evidence, {x=y}+{x<>y}.
  Proof.
    repeat decide equality.
  Defined.

  (* [term] type indexed on evidence produced. Each term type captures the
     type of evidence resulting from execution.

   - [TMeas e] - gather basic evidence value.  Could be any evidence type
   - [THash e] - results in a hash.
   - [TCrypt e p] - results in an encrypted thing using place [p]'s encryption
     key. For session keys [p] can be any aribitrary value.
   - [TSig e p] - results in a signed thing using place [p]'s local signing key.
   - [TSeq e f] - [e] followed by [f]
   - [TPar e f] - [e] in parallel with [f]
   *)
  Inductive term : evidence -> Type :=
  | TMeas : forall e, term e
  | THash : forall e, term e -> term EHash
  | TCrypt : forall e p, term e -> term (ECrypt e p)
  | TSig : forall e p, term e -> term (ESig e p)
  | TSeq : forall e f, term e -> term f -> term (ESeq e f)
  | TPar : forall e f, term e -> term f -> term (EPar e f).

  (* [term e] is indexed on [evidence] in a manner similar to an indexed abstract
     syntax for a programming language.  Every term is accompanied by the evidence
     type it produces.  Following are a few examples:
   *)
  
  Check TMeas (EBlob red).
  Definition blob := TMeas (EBlob red).
  Check (TSeq (TSig AA blob) (TPar blob (TPar blob blob))).
  Check (TSeq (TSig AA blob) (THash (TPar blob (TPar blob blob)))).
  Check THash (TMeas (EBlob red)).
  Check THash (TSig BB (TMeas (EBlob red))).
  Check (TSig BB (TMeas (EBlob red))).
  Check (TSeq (THash (TMeas (EBlob red))) (TMeas EHash)).
  Check TSeq (THash (TMeas (EBlob red))) (TSig AA (TMeas (EBlob red))).
  Check TSeq (THash (TMeas (EBlob red))) (TCrypt AA (TMeas (EBlob red))).
  Check TSeq (THash (TMeas (EPrivKey AA))) (TCrypt AA (TMeas (EBlob red))).
  Check TSeq (TMeas (EPrivKey AA)) (TCrypt AA (TMeas (EBlob red))).

  (* Blobs are things that may or may not need to be protected.  A hash
     typically will not need protection but a private key will.  There
     are various things one can do to blobs - hashing, signing, encrypting
     are the big three.  Hashing and encrypting protect blobs while signing
     does not.  Hashing always protects blobs.  Encrypting protects blobs
     unless the adversary can obtain inverse key to decrypt.

     Assume that some place [AA] has a privacy policy that does not allow any
     blob that is not a hash to be released.  The protocol:

     TSeq (THash (TMeas (EBlob red))) (TMeas EHash)
     : term (ESeq EHash EHash)

     satisfies this because its type tells us it returns a sequence of
     hashes.

     The protocol:

     TSeq (THash (TMeas (EBlob red))) (TSig AA (TMeas (EBlob 0)))
     : term (ESeq EHash (ESig (EBlob red) AA))

     does not satisfy this because its type tells us it returns a
     signature over (EBlob red) that does not protect it.

     In contrast, the protocol:
     
     TSeq (THash (TMeas (EBlob red))) (TCrypt AA (TMeas (EBlob red)))
     : term (ESeq EHash (ECrypt (EBlob red) AA))

     again satisfies this because its type tells us it returns
     an encrypted (EBlob 0) that protects it.

     Now a harder one:

     TSeq (TMeas EPrivKey) (TCrypt AA (TMeas (EBlob red)))
     : term (ESeq EPrivKey (ECrypt (EBlob red) AA))

     Literally we do not meet the requirement of only returning hashes and
     encrypted data.  But how dangerous is this protocol?  There is a private
     key returned by the first term.  Never good, but even worse if that
     private key corresponds with the encrypted blob.  Because we do not
     record whose private key this is we cannot make a strong assessment.
     
     Changing the definition of EPrivKey just a bit allows a stronger
     assessment:

     TSeq (TMeas (EPrivKey AA)) (TCrypt AA (TMeas (EBlob red)))
     : term (ESeq (EPrivKey AA) (ECrypt (EBlob red) AA))

     Here EPrivKey records whose private key is being reported.  Now we know
     this is particularly dangerous.  While this is a rather contrived
     example, remember that we are trying to prevent errors in attestation
     protocols, not prevent adversaries from writing hostile protocols.

   *)

  (* Now if we can express privacy policy over [evidence] in the type space
     we will have privacy checking in the type system.  This is next!!
   *)
  
  (* A function that checks signatures.  Basically, if the signed thing is
     signed by the provided place, the check is true. We've switched to
     the term space here and are not using typing results.
   *)
  Definition checkSig (t:evidence)(p q:place)(e: term (ESig t p)) : Prop :=
    p = q.

  (* This will not typecheck.  Trying to check the signature of a thing
     that is not signed. Note this is caught in _typechecking_
  
  Example e0: checkSig AA (THash (TMeas (EBlob red))).

  Error:
  The term "THash (TMeas (EBlob red))" has type "term EHash"
  while it is expected to have type "term (ESig ?t ?p)".
  *)

  Example e1: checkSig AA (TSig AA (TMeas (EBlob red))).
  Proof.
    unfold checkSig.
    congruence.
  Qed.
    
  Example e2: checkSig BB (TSig AA (TMeas (EBlob red))) -> False.
  Proof.
    unfold checkSig.
    intros.
    inversion H.
  Qed.
  
  (* A privacy policy that maps each evidence type to [True] or [False] indicating
     whether evidence can be exposed. *)
  
  Fixpoint privPolicy (e:evidence): bool :=
    match e with
    | EHash => true
    | EBlob red => false
    | EBlob green => true
    | EPrivKey _ => false
    | EPubKey _ => true
    | ESessKey _ => false
    | ESig e' _ => privPolicy e'
    | ECrypt _ _ => true
    | ESeq l r => andb (privPolicy l) (privPolicy r)
    | EPar l r => andb (privPolicy l) (privPolicy r)
    end.

  (* Privacy policy defined over [term] rather than [evidence] if such a thing
     is ever needed.
   *)
  
  Definition privPolicyT e (t:term e) := privPolicy e.


  (* Some examples that seem to indicate we can extract and use the evidence type.
     Note this is not a typecheck type, but at run time *)

  Compute privPolicyT (TMeas (EBlob red)).
  Compute privPolicyT (THash (TMeas (EBlob red))).
  Compute privPolicyT (TCrypt AA (TMeas (EBlob red))).
  Compute privPolicyT (TSig AA (TMeas (EBlob red))).
  Compute privPolicyT (TSig BB (TCrypt AA (TMeas (EBlob red)))).

  (* Some helper proofs used as input to the selection function. *)
  Lemma pp0: privPolicy (EBlob green) = true.
  Proof.
    auto.
  Qed.

  Lemma pp1: privPolicy (EBlob red) = true -> False.
  Proof.
    intros.
    simpl in H.
    inversion H.
  Qed.

  Lemma pp2: true = privPolicyT (TMeas (EBlob green)).
  Proof.
    auto.
  Qed.

  (* Subset domain type defining all policies that satisfy [privPolicyT].
     Defined the signature for such functions, but not actual example functions yet.
     Coq type checker is stopping me from doing anything reasonable.
   *)

     (*
  Definition selectDep'' e (_:term e) : {t:term e | true = (privPolicyT t)} :=
    (exist _ (TMeas (EBlob green)) _).
   *)

  (*
  Definition selectDep''' e (t:term e) : {t:term e | true = (privPolicy e)} :=
    (exist _ (TMeas (EBlob green)) pp2).
   *)  
  
  (* Alternative definition of a selection function that uses a proof term
     to guard the return value like we did with `pred_strong` in Chlipala. This
     is a very silly function that always returns [TMeas], but it is our first
     selection policy.  Specifically, no matter what the request, [r], is the protocol
     [TMeas] will be returned as long as the evidence requested is [green].
   *)
  
  (* Definition selectDepFn e (r:term e) : true = privPolicy e -> term e :=
    fun p => TMeas (e).

  Compute selectDepFn (THash (TMeas (EBlob green))).
  
  Example s1: (selectDepFn (THash (TMeas (EBlob green))) pp0) = TMeas EHash.
  auto. Qed.
  Example s2: (selectDepFn (THash (TMeas (EBlob red))) pp0) = TMeas EHash.
  auto. Qed.
  (* There is no proof that [(TMeas (EBlog red))] is [green], so this calculation
     will not complete.
   *)
  Example s3: (selectDepFn (TMeas (EBlob red))) =
              fun _ : true = privPolicy (EBlob red) => TMeas (EBlob red). *)

  (*
  Definition selectDep'' e (_:term e) : {t:term e | true = (privPolicyT t)} :=
    (exist _ (TMeas (EBlob green)) _).
   *)

  (*
  Definition selectDep''' e (t:term e) : {t:term e | true = (privPolicy e)} :=
    (exist _ (TMeas (EBlob green)) pp2).
   *)  
  
  (* Alternative definition of a selection function that uses a proof term
     to guard the return value like we did with `pred_strong` in Chlipala. This
     is a very silly function that always returns [TMeas], but it is our first
     selection policy.  Specifically, no matter what the request, [r], is the protocol
     [TMeas] will be returned as long as the evidence requested is [green].
   *)
  Definition selectDepFn e (r:term e) : true = privPolicy e -> term e :=
    fun p => TMeas (e).

  Compute selectDepFn (THash (TMeas (EBlob green))).
  
  Example s1: (selectDepFn (THash (TMeas (EBlob green))) pp0) = TMeas EHash.
  auto. Qed.
  Example s2: (selectDepFn (THash (TMeas (EBlob red))) pp0) = TMeas EHash.
  auto. Qed.
  (* There is no proof that [(TMeas (EBlog red))] is [green], so this calculation
     will not complete.
   *)
  Example s3: (selectDepFn (TMeas (EBlob red))) =
              fun _ : true = privPolicy (EBlob red) => TMeas (EBlob red).
              auto. Qed. 
  
  
  Definition selectDep'' e (t:term e) : {t:term e | privPolicyT t = true}.
  Proof.
  Abort.
                                        
  Definition selectDep''' e (t:term e) : {t:term e | privPolicy e = true}.
  Proof.
  Abort.
  
  (* An attempt to create a type for privacy policy using techniques from CPDT.
     No longer using subset type.  This is not working. *)
  Fixpoint privPolicyType (e:evidence) := (match e with
                                       | EHash => (option class)
                                       | EBlob green => (option class)
                                       | EBlob red => (option class)
                                       | EPrivKey _ => (option class)
                                       | EPubKey _ => (option class)
                                       | ESessKey _ => (option class)
                                       | ESig e p => privPolicyType e
                                       | ECrypt e p => (option evidence)
                                       | ESeq e1 e2 => if (privPolicyType e1) = (Some e1) then (privPolicyType e2) else None
                                          (*| _ => (option unit)*)
                                       end).
   
  
  (* All these examples compute the type as [option evidence] which makes sense
     given the [privPolicyType] function above.
  Compute privPolicyType EHash.
  Compute privPolicyType (EBlob red).
  Compute privPolicyType (EBlob green).
  Compute privPolicyType (ESig (EBlob red) AA).
  Compute privPolicyType (ESig (EBlob green) AA).
  Compute privPolicyType (ECrypt (EBlob red) AA)
   *)

  (* [privPolEx] returns the classification level of evidence. *)

  Fixpoint privPolEx (e:evidence):class :=
    match e with
    | EBlob c => c
    | EHash => green
    | EPrivKey _ => red
    | EPubKey _ => green
    | (ESessKey _) => red
    | (ESig e p) => privPolEx e
    | (ECrypt _ _) => green
    | ESeq l r => match (privPolEx l) with
                 | red => red
                 | green => (privPolEx r)
                 end
    | EPar l r => match (privPolEx l) with
                 | red => red
                 | green => (privPolEx r)
                 end
    end.

  (* [policyCheck] computes the classfication level of evidence produced by some term, [t].
     It uses [privPolEx] on the evidence index.

     | TMeas e' => privPolEx e'
    | THash t' => green
    | TCrypt _ _ => green
    | TSig _ t' => policyCheck t'
    | TSeq l r => match policyCheck l with
                 | red => red
                 | green => policyCheck r
                 end
    | TPar l r => match policyCheck l with
                 | red => red
                 | green => policyCheck r
   *)
  Fixpoint policyCheck e (t:term e):class :=
    match t with
    | THash t' => Some EHash t'
    | TMeas ev => match ev in evidence return (privPolicyType ev) with
                 | EBlob Green => Some (EBlob Green)
                 | EBlob Red => None
                 | EHash => Some EHash
                 | EPrivKey _ => None
                 | EPubKey p => Some (EPubKey p)
                 | ESessKey n => None
                 | ECrypt p e => Some (ECrypt p e)
                 | ESig (EBlob Red) p => None
                 | ESig (EBlob Green) p => Some (EBlob Green) 
                 | _ => None           
                 end
    end.
  
  Compute policyCheck (TMeas (EBlob red)).
  Compute policyCheck (TSeq (TSig AA blob) (TPar blob (TPar blob blob))).
  Compute policyCheck (TSeq (TSig AA blob) (THash (TPar blob (TPar blob blob)))).
  Compute policyCheck (THash (TMeas (EBlob red))).
  Compute policyCheck (THash (TSig BB (TMeas (EBlob red)))).
  Compute policyCheck (TSig BB (TMeas (EBlob red))).
  Compute policyCheck (TSeq (THash (TMeas (EBlob red))) (TMeas EHash)).
  Compute policyCheck (TSeq (THash (TMeas (EBlob red))) (TSig AA (TMeas (EBlob red)))).
  Compute policyCheck (TSeq (THash (TMeas (EBlob red))) (TCrypt AA (TMeas (EBlob red)))).
  Compute policyCheck (TSeq (THash (TMeas (EPrivKey AA))) (TCrypt AA (TMeas (EBlob red)))).
  Compute policyCheck (TSeq (TMeas (EPrivKey AA)) (TCrypt AA (TMeas (EBlob red)))).

  (* A [goodTerm] is a term that generates [green] terms. *)
  
  Definition goodTerm := forall e, {t:term e | policyCheck t = green}.
  
  (* A [goodTermEv] is a term that generates [green] evidence. *)

  Definition goodTermEv := forall e, {t:term e | privPolEx e = green}.

  (* This is an attempt to mimic CPDT that is not working.  I believe due to
     the inability to match on [e], but I'm not 100% certain.
   *)
  Definition selectDep' e (t:(term e)) := 
    match t with
    | TMeas t => Some tt
    | THash _ => EHash
    | _ => Some EHash
    end.

  (* Copied from above for documentation
  | TMeas : forall e, term e
  | THash : forall e, term e -> term EHash
  | TCrypt : forall e p, term e -> term (ECrypt e p)
  | TSig : forall e p, term e -> term (ESig e p)
  | TSeq : forall e f, term e -> term f -> term (ESeq e f)
  | TPar : forall e f, term e -> term f -> term (EPar e f).
   *)
  
  Compute selectDep' (THash blob).
  Compute privPolicyType EHash.
  
  Definition selectDep e (t:term e):term e:=
    match t in (term e') return (match e' with
                                | EHash => term e'
                                | EBlob _ => term e'
                                | EPrivKey _ => term e'
                                | EPubKey _ => term e'
                                | ESessKey _ => term e'
                                | ESig _ _ => term e'
                                | ECrypt _ _ => term e'
                                | ESeq l r => term e'
                                | EPar l r => term e'
                                end) with
      | TMeas e => TMeas (EBlob 0)
      | THash _ => THash
      | TCrypt e p => TCrypt e
    end.

End DepCopland.
